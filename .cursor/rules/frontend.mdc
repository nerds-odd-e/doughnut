---
description: Vue.js frontend development, Vue 3, TypeScript, components, testing, Vitest, DaisyUI, Tailwind, API integration, linting
alwaysApply: false
---
# Frontend Development Cursor Rules

## When to Use This Rule

**Use this rule when:**
- Writing or modifying Vue components
- Working with frontend TypeScript code
- Creating or updating frontend tests
- Integrating with backend APIs
- Styling components with DaisyUI/Tailwind
- Fixing linting or type errors in frontend code
- Organizing frontend file structure

## Run Test in Terminal

**For command execution details (cloud agent vs local), see the `cloud-agent-setup` rule.**

**Cloud Agent:**
```bash
pnpm frontend:test
```

**Local Development:**
```bash
CURSOR_DEV=true nix develop -c pnpm frontend:test
```

## Linting and Type Checking

**IMPORTANT**: The Vite dev server runs linting and type checking in the background using `vite-plugin-checker`. The overlay is disabled (`overlay: false`) to prevent blocking e2e tests, but errors still appear in the terminal.

- **Always check the terminal output** where `pnpm sut` is running for linting/type errors
- **Before completing any task**, run `pnpm format:all` to fix formatting and check for any remaining linting errors
- **Fix all linting errors** - they won't block the browser UI but must be resolved

To check for linting errors:
```bash
CURSOR_DEV=true nix develop -c pnpm lint:all
```

To fix formatting issues:
```bash
CURSOR_DEV=true nix develop -c pnpm format:all
```

## File Organization

- Frontend code lives in `frontend/src/`
- Test code lives in `frontend/tests/`
- Generated backend API code is in `frontend/src/generated/backend`

## Core Technologies

- Vue 3 with TypeScript
- DaisyUI + Tailwind for styling, with "daisy-" prefix
- Vitest for testing
- Biome for linting/formatting

## Component Rules

### Naming Conventions

- Component files should use PascalCase (e.g., `NoteShow.vue`, `GlobalBar.vue`)
- Test files should match component names with `.spec.ts` suffix
- Use `.vue` extension for components
- Use `.ts` extension for TypeScript files

### Component Structure

```vue
<script setup lang="ts">
// imports first
import { ref } from "vue"

// props/emits
const props = defineProps<{
  value: string
}>()
const emit = defineEmits<{
  (e: 'update:value', value: string): void
}>()

// composables/setup
// Import services directly from generated SDK
import { getUserProfile } from "@generated/backend/sdk.gen"

// refs/reactive state
const loading = ref(false)

// computed
const displayValue = computed(() => props.value.toUpperCase())

// methods
const handleClick = () => {
  emit('update:value', 'new value')
}

// lifecycle hooks last
onMounted(() => {
  // ...
})
</script>

<template>
  <div class="daisy-component">
    <!-- template content -->
  </div>
</template>

<style scoped lang="scss">
// scoped styles
</style>
```
### API Integration

- Import services directly from `@generated/backend/sdk.gen`
- The global client is automatically configured with interceptors for loading states and error handling (set up in `DoughnutApp.vue`)
- Use the wrapped response pattern: `{ data, error, request, response }`
- Follow the API types from generated code
- For silent calls (no loading indicators or error toasts), use `globalClientSilent` from `@/managedApi/clientSetup`:
  ```typescript
  import { askAQuestion } from "@generated/backend/sdk.gen"
  import { globalClientSilent } from "@/managedApi/clientSetup"
  
  const { data, error } = await askAQuestion({
    path: { memoryTracker: trackerId },
    client: globalClientSilent, // Use silent client for background calls
  })
  ```

### API Return Value Usage Pattern

The global client is configured with `responseStyle: "fields"` and `throwOnError: false`, which means services return a wrapped response: `{ data, error, request, response }`.

**Usage Pattern:**

```typescript
// Import services directly from generated SDK
import { getTokens, generateToken } from "@generated/backend/sdk.gen"

// Destructure the response with meaningful variable names
const { data: tokens, error } = await getTokens()

// Check for errors before using data
if (!error) {
  // TypeScript guarantees data is the correct type (e.g., UserToken[])
  // When error is undefined, data is always the correct type
  tokens.value = tokens.map((t) => ({
    id: t.id,
    label: t.label,
  }))
}
```

**Key Points:**

1. Always destructure with meaningful variable names: `const { data: updatedUser, error } = await updateUser(...)`
2. Check `!error` before using data (no need to check `data` separately)
3. TypeScript types are guaranteed: when `error` is undefined, `data` is always the correct type
4. No need for runtime property checks: if the type says `token: string`, it's always present
5. No need for `else if (data)` check: when `error` is undefined, `data` is always defined and has the correct type
6. Errors are handled in the response interceptor: the global client's interceptor handles error display (toasts, loading states, etc.)

**Example:**

```typescript
const generateToken = async () => {
  loading.value = true
  const { data: newToken, error } = await generateTokenApi({
    body: { label: tokenFormData.value.label },
  })
  if (!error) {
    // newToken is guaranteed to be UserToken type when error is undefined
    token.value = newToken.token
    tokens.value.push({
      id: newToken.id,
      label: newToken.label,
    })
  }
  loading.value = false
}
```

This pattern provides type safety and consistent error handling through the global client interceptors.

### Handling Validation Errors (400 Bad Request)

When handling 400 Bad Request errors with validation errors, use the `toOpenApiError` helper to extract field-level errors. The `error` field in API responses is typed as `string` but can be an object at runtime (parsed JSON).

**Usage Pattern:**

```typescript
import { toOpenApiError } from "@/managedApi/openApiError"

// In your component
const errors = ref<Record<string, string>>({})

const processForm = async () => {
  const { data, error } = await updateUser({
    path: { user: formData.value.id },
    body: formData.value,
  })
  if (error) {
    // Error is handled by global interceptor (toast notification)
    // Extract field-level errors if available (for 400 validation errors)
    const errorObj = toOpenApiError(error)
    errors.value = errorObj.errors || {}
  } else if (data) {
    errors.value = {}
    // Handle success
  }
}
```

**Key Points:**

1. Use `toOpenApiError(error)` to convert the error (typed as `string` but can be an object) to `OpenApiError`
2. `OpenApiError` type: `{ errors?: Record<string, string>; message?: string }`
3. The helper safely handles both string and object errors
4. Extract `errors` field for field-level validation errors (typically from 400 responses)
5. Global interceptor already handles error display (toasts), so you only need to extract field-level errors for form validation

**Example:**

```typescript
const { data: updatedUser, error } = await updateUser({ path: { user: id }, body: formData })
if (error) {
  const errorObj = toOpenApiError(error)
  // errorObj.errors contains field-level validation errors
  // e.g., { "name": "Name is required", "email": "Invalid email format" }
  errors.value = errorObj.errors || {}
} else {
  // updatedUser is guaranteed to be User type when error is undefined
  // Handle success case
}
```

### CSS/Styling Rules

- Use DaisyUI classes with `daisy-` prefix (e.g., `daisy-btn`, `daisy-alert`)
- Avoid Bootstrap classes
- Choose theme-neutral colors
- Use scoped styles with SCSS
- Follow mobile-first responsive design

### Testing Guidelines

1. Focus on Component Behavior
   - Test through user interactions
   - Avoid testing implementation details
   - Use data-testid for test selectors

2. Minimal Mocking
   - Mock only external dependencies (API calls)
   - Use real component instances when possible
   - Mock services directly from `@generated/backend/sdk.gen`:
   ```typescript
   import * as sdk from "@generated/backend/sdk.gen"
   
   vi.spyOn(sdk, "getUserProfile").mockResolvedValue({
     data: makeMe.aUser.please(),
     error: undefined,
     request: {} as Request,
     response: {} as Response,
   })
   ```

2. **Component Props**
   - Use `helper.component(ComponentName).withStorageProps` if the component requires a prop `storageAccessor`. Do not need to pass a `storageAccessor` any more because the helper will add it to the props
   - If the component doesn't require `storageAccessor` in the props then just use 'withProps' instead of 'withStorageProps'
   - Test prop changes and their effects
   - Example:
   ```typescript
   const wrapper = helper
     .component(Component)
     .withStorageProps({ value: initialValue })
     .mount()
   await wrapper.setProps({ value: newValue })
   ```

4. **Data Builder Pattern**
   - Use makeMe factory for creating test data
   - Builders handle complex object creation
   - Example:
   ```typescript
   const note = makeMe.aNoteRealm
     .topicConstructor("Dummy Title")
     .details("Description")
     .please()
   ```

5. "mount" vs "render"
   - the test helper can either mount or render the component. "render" will call the testing-library render and mount will call the vuejs test util mount.
   - In either style testing, the test should avoid finding VueJS component in the render or mount result, so that the test can be more end to end.

6. **Avoid If-Conditions in Tests**
   - Tests must be deterministic - they should always execute the same way
   - Use assertions instead of if-conditions to ensure tests fail clearly when expectations aren't met
   - Use sequential async operations instead of loops where possible
   - Example - Bad (non-deterministic):
   ```typescript
   if (vm.searchResults) {
     const selected = vm.searchResults.find((r) => r.id === wikidataId)
     if (selected) {
       // do something
     }
   }
   ```
   - Example - Good (deterministic):
   ```typescript
   expect(vm.searchResults).toBeDefined()
   expect(vm.searchResults.length).toBeGreaterThan(0)
   const selected = vm.searchResults.find((r) => r.id === wikidataId)
   expect(selected).toBeDefined()
   // do something with selected
   ```
