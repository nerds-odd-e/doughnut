---
description: Vue.js frontend development, Vue 3, TypeScript, components, testing, Vitest (with playwright browser-mode), DaisyUI, Tailwind, API integration, linting
alwaysApply: false
---
# Frontend Development Cursor Rules

## When to Use This Rule

**Use this rule when:**
- Writing or modifying Vue components
- Working with frontend TypeScript code
- Creating or updating frontend tests
- Integrating with backend APIs
- Styling components with DaisyUI/Tailwind
- Fixing linting or type errors in frontend code
- Organizing frontend file structure

## Run Test in Terminal

### Running All Tests

```bash
CURSOR_DEV=true nix develop -c pnpm frontend:test
```

### Running a Single Test File

```bash
CURSOR_DEV=true nix develop -c pnpm -C frontend test tests/path/to/TestFile.spec.ts
```

**Running a specific test case within a file:**
```bash
CURSOR_DEV=true nix develop -c pnpm -C frontend test -t "test name pattern"
```

**Note:** The test file path is relative to the `frontend/` directory.

**IMPORTANT: In most situations, you should run all unit tests instead of a selected file only.** Running all tests ensures you catch any regressions or side effects your changes might have introduced. Only run a single test file when you're actively debugging a specific test or iterating on a specific component.


## Linting and Type Checking

**IMPORTANT**: The Vite dev server runs linting and type checking in the background using `vite-plugin-checker`. The overlay is disabled (`overlay: false`) to prevent blocking e2e tests, but errors still appear in the terminal.

- **Always check the terminal output** where `pnpm sut` is running for linting/type errors
- **Before completing any task**, run `pnpm format:all` to fix formatting and check for any remaining linting errors
- **Fix all linting errors** - they won't block the browser UI but must be resolved

To check for linting errors:
```bash
CURSOR_DEV=true nix develop -c pnpm lint:all
```

To fix formatting issues:
```bash
CURSOR_DEV=true nix develop -c pnpm format:all
```

## File Organization

- Frontend code lives in `frontend/src/`
- Test code lives in `frontend/tests/`
- Generated backend API code is in `frontend/src/generated/backend`

## Core Technologies

- Vue 3 with TypeScript
- DaisyUI + Tailwind for styling, with "daisy-" prefix
- Vitest for testing (with playwright browser mode)
- Biome for linting/formatting

## Component Rules

### Naming Conventions

- Component files should use PascalCase (e.g., `NoteShow.vue`, `GlobalBar.vue`)
- Test files should match component names with `.spec.ts` suffix
- Use `.vue` extension for components
- Use `.ts` extension for TypeScript files

### Component Structure

```vue
<script setup lang="ts">
// imports first
import { ref } from "vue"

// props/emits
const props = defineProps<{
  value: string
}>()
const emit = defineEmits<{
  (e: 'update:value', value: string): void
}>()

// composables/setup
// Import services directly from generated SDK
import { getUserProfile } from "@generated/backend/sdk.gen"

// refs/reactive state
const loading = ref(false)

// computed
const displayValue = computed(() => props.value.toUpperCase())

// methods
const handleClick = () => {
  emit('update:value', 'new value')
}

// lifecycle hooks last
onMounted(() => {
  // ...
})
</script>

<template>
  <div class="daisy-component">
    <!-- template content -->
  </div>
</template>

<style scoped lang="scss">
// scoped styles
</style>
```
### API Integration

- Import services directly from `@generated/backend/sdk.gen`
- Use the wrapped response pattern: `{ data, error, request, response }`
- Follow the API types from generated code

**Loading State and Error Handling:**
- Use `apiCallWithLoading` wrapper for user-initiated actions that need loading indicators
- Wrapped calls show loading state and error toasts automatically
- Non-wrapped calls are silent (no loading, no error toasts)

```typescript
import { UserController } from "@generated/backend/sdk.gen"
import { apiCallWithLoading } from "@/managedApi/clientSetup"

// For user actions (shows loading + error toasts)
const { data: newUser, error } = await apiCallWithLoading(() =>
  UserController.createUser({
    body: formData,
  })
)

// For background fetches (silent - no loading, no error toasts)
const { data: users, error } = await UserController.getUserProfile()
```

### API Return Value Usage Pattern

The global client is configured with `responseStyle: "fields"` and `throwOnError: false`, which means services return a wrapped response: `{ data, error, request, response }`.

**Usage Pattern:**

```typescript
// Import services directly from generated SDK
import { getTokens, generateToken } from "@generated/backend/sdk.gen"

// Destructure the response with meaningful variable names
const { data: tokens, error } = await getTokens()

// Check for errors before using data
if (!error) {
  // TypeScript guarantees data is the correct type (e.g., UserToken[])
  // When error is undefined, data is always the correct type
  tokens.value = tokens.map((t) => ({
    id: t.id,
    label: t.label,
  }))
}
```

**Key Points:**

1. Always destructure with meaningful variable names: `const { data: updatedUser, error } = await updateUser(...)`
2. Check `!error` before using data (no need to check `data` separately)
3. TypeScript types are guaranteed: when `error` is undefined, `data` is always the correct type
4. No need for runtime property checks: if the type says `token: string`, it's always present
5. No need for `else if (data)` check: when `error` is undefined, `data` is always defined and has the correct type
6. Use `apiCallWithLoading` for user actions to enable error toasts and loading state

**Example:**

```typescript
import { apiCallWithLoading } from "@/managedApi/clientSetup"

const generateToken = async () => {
  const { data: newToken, error } = await apiCallWithLoading(() =>
    UserController.generateToken({
      body: { label: tokenFormData.value.label },
    })
  )
  if (!error) {
    // newToken is guaranteed to be UserToken type when error is undefined
    token.value = newToken.token
    tokens.value.push({
      id: newToken.id,
      label: newToken.label,
    })
  }
}
```

This pattern provides type safety, automatic loading state, and error handling for user actions.

### Handling Validation Errors (400 Bad Request)

When handling 400 Bad Request errors with validation errors, use the `toOpenApiError` helper to extract field-level errors. The `error` field in API responses is typed as `string` but can be an object at runtime (parsed JSON).

**Usage Pattern:**

```typescript
import { toOpenApiError } from "@/managedApi/openApiError"
import { apiCallWithLoading } from "@/managedApi/clientSetup"

// In your component
const errors = ref<Record<string, string>>({})

const processForm = async () => {
  const { data, error } = await apiCallWithLoading(() =>
    UserController.updateUser({
      path: { user: formData.value.id },
      body: formData.value,
    })
  )
  if (error) {
    // Error toast is shown automatically by apiCallWithLoading
    // Extract field-level errors if available (for 400 validation errors)
    const errorObj = toOpenApiError(error)
    errors.value = errorObj.errors || {}
  } else if (data) {
    errors.value = {}
    // Handle success
  }
}
```

**Key Points:**

1. Use `toOpenApiError(error)` to convert the error (typed as `string` but can be an object) to `OpenApiError`
2. `OpenApiError` type: `{ errors?: Record<string, string>; message?: string }`
3. The helper safely handles both string and object errors
4. Extract `errors` field for field-level validation errors (typically from 400 responses)
5. `apiCallWithLoading` shows error toasts automatically, you only need to extract field-level errors for form validation

**Example:**

```typescript
const { data: updatedUser, error } = await apiCallWithLoading(() =>
  UserController.updateUser({ path: { user: id }, body: formData })
)
if (error) {
  const errorObj = toOpenApiError(error)
  // errorObj.errors contains field-level validation errors
  // e.g., { "name": "Name is required", "email": "Invalid email format" }
  errors.value = errorObj.errors || {}
} else {
  // updatedUser is guaranteed to be User type when error is undefined
  // Handle success case
}
```

### CSS/Styling Rules

- Use DaisyUI classes with `daisy-` prefix (e.g., `daisy-btn`, `daisy-alert`)
- Avoid Bootstrap classes
- Choose theme-neutral colors
- Use scoped styles with SCSS
- Follow mobile-first responsive design

### Testing Guidelines

1. Focus on Component Behavior
   - Test through user interactions
   - Avoid testing implementation details
   - Use data-testid for test selectors
   - Test with vitest-browser-mode as [mentioned here](https://howtotestfrontend.com/resources/vitest-browser-mode-guide-and-setup-info); i.e. prefer real browser rendering in tests over mocking (stop using jsdom).

2. **Avoid `xxxByRole` Queries (Performance Optimization)**
   - **DO NOT use `getByRole`, `findByRole`, `queryByRole`, `getAllByRole`, etc.** - they are slow due to expensive visibility checks
   - **Note**: Testing Library officially recommends `getByRole` as the top priority for accessibility, but this project prioritizes test performance
   - Use faster alternatives: `getByText`, `getByLabelText`, `getByTitle`, or `querySelector`/`querySelectorAll`

3. **Mocking SDK Services**
   - Use `mockSdkService` from `@tests/helpers` for type-safe mocking
   - Automatically wraps responses in the standard format `{ data, error, request, response }`
   - Returns a spy that can be reconfigured in tests
   - Use `wrapSdkResponse` when updating mock return values
   - Only use `mockSdkServiceWithImplementation` for custom async logic based on options

   **Simple mocking:**
   ```typescript
   import { mockSdkService } from "@tests/helpers"

   beforeEach(() => {
     mockSdkService("getRecentNotes", [])
     mockSdkService("showNote", makeMe.aNoteRealm.please())
   })
   ```

   **Reconfiguring mocks in tests:**
   ```typescript
   import { mockSdkService, wrapSdkResponse } from "@tests/helpers"

   const spy = mockSdkService("showNote", makeMe.aNoteRealm.please())
   // Later in test:
   spy.mockResolvedValue(wrapSdkResponse(differentNote))
   ```

   **Custom implementation (only when needed):**
   ```typescript
   import { mockSdkServiceWithImplementation } from "@tests/helpers"

   mockSdkServiceWithImplementation("updateNoteDetails", async (options) => {
     // Custom logic based on options
     return await someAsyncOperation(options)
   })
   ```

4. **Component Props**
   - Use `helper.component(ComponentName).withStorageProps` if the component requires a prop `storageAccessor`. Do not need to pass a `storageAccessor` any more because the helper will add it to the props
   - If the component doesn't require `storageAccessor` in the props then just use 'withProps' instead of 'withStorageProps'
   - Test prop changes and their effects
   - Example:
   ```typescript
   const wrapper = helper
     .component(Component)
     .withStorageProps({ value: initialValue })
     .mount()
   await wrapper.setProps({ value: newValue })
   ```

5. **Data Builder Pattern**
   - Use makeMe factory for creating test data
   - Builders handle complex object creation
   - Example:
   ```typescript
   const note = makeMe.aNoteRealm
     .topicConstructor("Dummy Title")
     .details("Description")
     .please()
   ```

6. "mount" vs "render"
   - the test helper can either mount or render the component. "render" will call the testing-library render and mount will call the vuejs test util mount.
   - In either style testing, the test should avoid finding VueJS component in the render or mount result, so that the test can be more end to end.

7. **Avoid If-Conditions in Tests**
   - Tests must be deterministic - they should always execute the same way
   - Use assertions instead of if-conditions to ensure tests fail clearly when expectations aren't met
   - Use sequential async operations instead of loops where possible
   - Example - Bad (non-deterministic):
   ```typescript
   if (vm.searchResults) {
     const selected = vm.searchResults.find((r) => r.id === wikidataId)
     if (selected) {
       // do something
     }
   }
   ```
   - Example - Good (deterministic):
   ```typescript
   expect(vm.searchResults).toBeDefined()
   expect(vm.searchResults.length).toBeGreaterThan(0)
   const selected = vm.searchResults.find((r) => r.id === wikidataId)
   expect(selected).toBeDefined()
   // do something with selected
   ```

## Storybook

### Running Storybook

To start Storybook locally for component development and debugging:

```bash
pnpm storybook
```

This will start Storybook on `http://localhost:6006` by default.

### Shared Test Data Builders

Storybook stories reuse the same test data builders that are used in unit tests. These builders are located in `tests/fixtures/` and can be imported using the `@tests` alias:

```typescript
import makeMe from '@tests/fixtures/makeMe'
```

The `makeMe` object provides access to all test data builders:
- `makeMe.anAnsweredQuestion` - Creates answered question data
- `makeMe.aPredefinedQuestion` - Creates predefined question data
- `makeMe.aNote` - Creates note data
- `makeMe.aNoteRealm` - Creates note realm data
- And many more...

**Example Usage:**

```typescript
import makeMe from '@tests/fixtures/makeMe'

// Create an answered question with correct answer
const correctQuestion = makeMe.anAnsweredQuestion
  .answerCorrect(true)
  .withChoiceIndex(0)
  .please()

// Create a question with a note
const questionWithNote = makeMe.anAnsweredQuestion
  .withNote(makeMe.aNote.topicConstructor('TypeScript').please())
  .answerCorrect(true)
  .please()
```

### Writing a New Story

To create a new Storybook story for a component:

1. Create a file named `ComponentName.stories.ts` in the same directory as your component
2. Import the component and necessary builders
3. Define the story meta and stories

**Example Story:**

```typescript
import type { Meta, StoryObj } from '@storybook/vue3'
import MyComponent from './MyComponent.vue'
import makeMe from '@tests/fixtures/makeMe'

const meta = {
  title: 'Category/MyComponent',
  component: MyComponent,
  tags: ['autodocs'],
} satisfies Meta<typeof MyComponent>

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {
  args: {
    prop1: makeMe.someBuilder.please(),
  },
}
```

**Story Variants:**

Create multiple story variants to showcase different states:

```typescript
export const Variant1: Story = {
  args: {
    // ... props for variant 1
  },
}

export const Variant2: Story = {
  args: {
    // ... props for variant 2
  },
}
```

### Module Aliases

Storybook is configured to support the same module aliases as the main application:
- `@/` - Points to `src/`
- `@tests/` - Points to `tests/`
- `@generated/` - Points to `generated/`

### Global Styles

Storybook automatically loads the global styles from `src/assets/daisyui.css`, which includes:
- Tailwind CSS base styles
- DaisyUI component styles
- Custom application styles

### Storybook Best Practices

1. **Reuse Builders**: Always use the shared test data builders from `@tests/fixtures/makeMe` instead of creating mock data
2. **No Duplication**: Never duplicate mock data - use builders for consistency
3. **Multiple Variants**: Create multiple story variants to showcase different component states
4. **Documentation**: Use the `autodocs` tag to automatically generate documentation
5. **Framework Neutral**: Builders are framework-neutral and work in both tests and Storybook
